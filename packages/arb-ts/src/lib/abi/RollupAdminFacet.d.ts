/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from 'ethers'
import { BytesLike } from '@ethersproject/bytes'
import { Listener, Provider } from '@ethersproject/providers'
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi'
import { TypedEventFilter, TypedEvent, TypedListener } from './commons'

interface RollupAdminFacetInterface extends ethers.utils.Interface {
  functions: {
    'STORAGE_GAP_1()': FunctionFragment
    'STORAGE_GAP_2()': FunctionFragment
    '_stakerMap(address)': FunctionFragment
    'amountStaked(address)': FunctionFragment
    'arbGasSpeedLimitPerBlock()': FunctionFragment
    'avmGasSpeedLimitPerBlock()': FunctionFragment
    'baseStake()': FunctionFragment
    'challengeExecutionBisectionDegree()': FunctionFragment
    'challengeFactory()': FunctionFragment
    'confirmPeriodBlocks()': FunctionFragment
    'currentChallenge(address)': FunctionFragment
    'delayedBridge()': FunctionFragment
    'extraChallengeTimeBlocks()': FunctionFragment
    'firstUnresolvedNode()': FunctionFragment
    'forceConfirmNode(uint256,bytes32,bytes,uint256[],uint256,bytes32,uint256)': FunctionFragment
    'forceCreateNode(bytes32,bytes32[3][2],uint256[4][2],bytes,uint256,uint256,uint256)': FunctionFragment
    'forceRefundStaker(address[])': FunctionFragment
    'forceResolveChallenge(address[],address[])': FunctionFragment
    'getNode(uint256)': FunctionFragment
    'getNodeHash(uint256)': FunctionFragment
    'getStakerAddress(uint256)': FunctionFragment
    'isMaster()': FunctionFragment
    'isStaked(address)': FunctionFragment
    'isZombie(address)': FunctionFragment
    'lastStakeBlock()': FunctionFragment
    'latestConfirmed()': FunctionFragment
    'latestNodeCreated()': FunctionFragment
    'latestStakedNode(address)': FunctionFragment
    'minimumAssertionPeriod()': FunctionFragment
    'nodeFactory()': FunctionFragment
    'outbox()': FunctionFragment
    'owner()': FunctionFragment
    'pause()': FunctionFragment
    'paused()': FunctionFragment
    'removeOldOutbox(address)': FunctionFragment
    'resume()': FunctionFragment
    'rollupEventBridge()': FunctionFragment
    'sequencerBridge()': FunctionFragment
    'setAvmGasSpeedLimitPerBlock(uint256)': FunctionFragment
    'setBaseStake(uint256)': FunctionFragment
    'setChallengeExecutionBisectionDegree(uint256)': FunctionFragment
    'setConfirmPeriodBlocks(uint256)': FunctionFragment
    'setExtraChallengeTimeBlocks(uint256)': FunctionFragment
    'setFacets(address,address)': FunctionFragment
    'setInbox(address,bool)': FunctionFragment
    'setIsSequencer(address,bool)': FunctionFragment
    'setMinimumAssertionPeriod(uint256)': FunctionFragment
    'setOutbox(address)': FunctionFragment
    'setOwner(address)': FunctionFragment
    'setSequencerInboxMaxDelay(uint256,uint256)': FunctionFragment
    'setStakeToken(address)': FunctionFragment
    'setValidator(address[],bool[])': FunctionFragment
    'setWhitelistEntries(address,address[],bool[])': FunctionFragment
    'stakeToken()': FunctionFragment
    'stakerCount()': FunctionFragment
    'updateWhitelistConsumers(address,address,address[])': FunctionFragment
    'upgradeBeacon(address,address)': FunctionFragment
    'withdrawableFunds(address)': FunctionFragment
    'zombieAddress(uint256)': FunctionFragment
    'zombieCount()': FunctionFragment
    'zombieLatestStakedNode(uint256)': FunctionFragment
  }

  encodeFunctionData(
    functionFragment: 'STORAGE_GAP_1',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'STORAGE_GAP_2',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: '_stakerMap', values: [string]): string
  encodeFunctionData(functionFragment: 'amountStaked', values: [string]): string
  encodeFunctionData(
    functionFragment: 'arbGasSpeedLimitPerBlock',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'avmGasSpeedLimitPerBlock',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'baseStake', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'challengeExecutionBisectionDegree',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'challengeFactory',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'confirmPeriodBlocks',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'currentChallenge',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'delayedBridge',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'extraChallengeTimeBlocks',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'firstUnresolvedNode',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'forceConfirmNode',
    values: [
      BigNumberish,
      BytesLike,
      BytesLike,
      BigNumberish[],
      BigNumberish,
      BytesLike,
      BigNumberish
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'forceCreateNode',
    values: [
      BytesLike,
      [[BytesLike, BytesLike, BytesLike], [BytesLike, BytesLike, BytesLike]],
      [
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
      ],
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'forceRefundStaker',
    values: [string[]]
  ): string
  encodeFunctionData(
    functionFragment: 'forceResolveChallenge',
    values: [string[], string[]]
  ): string
  encodeFunctionData(
    functionFragment: 'getNode',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getNodeHash',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getStakerAddress',
    values: [BigNumberish]
  ): string
  encodeFunctionData(functionFragment: 'isMaster', values?: undefined): string
  encodeFunctionData(functionFragment: 'isStaked', values: [string]): string
  encodeFunctionData(functionFragment: 'isZombie', values: [string]): string
  encodeFunctionData(
    functionFragment: 'lastStakeBlock',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'latestConfirmed',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'latestNodeCreated',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'latestStakedNode',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'minimumAssertionPeriod',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'nodeFactory',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'outbox', values?: undefined): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'removeOldOutbox',
    values: [string]
  ): string
  encodeFunctionData(functionFragment: 'resume', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'rollupEventBridge',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'sequencerBridge',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'setAvmGasSpeedLimitPerBlock',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setBaseStake',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setChallengeExecutionBisectionDegree',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setConfirmPeriodBlocks',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setExtraChallengeTimeBlocks',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setFacets',
    values: [string, string]
  ): string
  encodeFunctionData(
    functionFragment: 'setInbox',
    values: [string, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'setIsSequencer',
    values: [string, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'setMinimumAssertionPeriod',
    values: [BigNumberish]
  ): string
  encodeFunctionData(functionFragment: 'setOutbox', values: [string]): string
  encodeFunctionData(functionFragment: 'setOwner', values: [string]): string
  encodeFunctionData(
    functionFragment: 'setSequencerInboxMaxDelay',
    values: [BigNumberish, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setStakeToken',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'setValidator',
    values: [string[], boolean[]]
  ): string
  encodeFunctionData(
    functionFragment: 'setWhitelistEntries',
    values: [string, string[], boolean[]]
  ): string
  encodeFunctionData(functionFragment: 'stakeToken', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'stakerCount',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'updateWhitelistConsumers',
    values: [string, string, string[]]
  ): string
  encodeFunctionData(
    functionFragment: 'upgradeBeacon',
    values: [string, string]
  ): string
  encodeFunctionData(
    functionFragment: 'withdrawableFunds',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'zombieAddress',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'zombieCount',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'zombieLatestStakedNode',
    values: [BigNumberish]
  ): string

  decodeFunctionResult(
    functionFragment: 'STORAGE_GAP_1',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'STORAGE_GAP_2',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: '_stakerMap', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'amountStaked',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'arbGasSpeedLimitPerBlock',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'avmGasSpeedLimitPerBlock',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'baseStake', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'challengeExecutionBisectionDegree',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'challengeFactory',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'confirmPeriodBlocks',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'currentChallenge',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'delayedBridge',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'extraChallengeTimeBlocks',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'firstUnresolvedNode',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'forceConfirmNode',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'forceCreateNode',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'forceRefundStaker',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'forceResolveChallenge',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'getNode', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getNodeHash', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'getStakerAddress',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'isMaster', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isStaked', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isZombie', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'lastStakeBlock',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'latestConfirmed',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'latestNodeCreated',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'latestStakedNode',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'minimumAssertionPeriod',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'nodeFactory', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'outbox', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'removeOldOutbox',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'resume', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'rollupEventBridge',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'sequencerBridge',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setAvmGasSpeedLimitPerBlock',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setBaseStake',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setChallengeExecutionBisectionDegree',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setConfirmPeriodBlocks',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setExtraChallengeTimeBlocks',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'setFacets', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setInbox', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'setIsSequencer',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setMinimumAssertionPeriod',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'setOutbox', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setOwner', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'setSequencerInboxMaxDelay',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setStakeToken',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setValidator',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setWhitelistEntries',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'stakeToken', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'stakerCount', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'updateWhitelistConsumers',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'upgradeBeacon',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'withdrawableFunds',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'zombieAddress',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'zombieCount', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'zombieLatestStakedNode',
    data: BytesLike
  ): Result

  events: {
    'NodeConfirmed(uint256,bytes32,uint256,bytes32,uint256)': EventFragment
    'NodeCreated(uint256,bytes32,bytes32,bytes32,uint256,uint256,bytes32,bytes32[3][2],uint256[4][2])': EventFragment
    'NodeRejected(uint256)': EventFragment
    'OwnerFunctionCalled(uint256)': EventFragment
    'Paused(address)': EventFragment
    'RollupChallengeStarted(address,address,address,uint256)': EventFragment
    'RollupCreated(bytes32)': EventFragment
    'Unpaused(address)': EventFragment
    'UserStakeUpdated(address,uint256,uint256)': EventFragment
    'UserWithdrawableFundsUpdated(address,uint256,uint256)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'NodeConfirmed'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'NodeCreated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'NodeRejected'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OwnerFunctionCalled'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'RollupChallengeStarted'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'RollupCreated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'UserStakeUpdated'): EventFragment
  getEvent(
    nameOrSignatureOrTopic: 'UserWithdrawableFundsUpdated'
  ): EventFragment
}

export class RollupAdminFacet extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this

  listeners(eventName?: string): Array<Listener>
  off(eventName: string, listener: Listener): this
  on(eventName: string, listener: Listener): this
  once(eventName: string, listener: Listener): this
  removeListener(eventName: string, listener: Listener): this
  removeAllListeners(eventName?: string): this

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>

  interface: RollupAdminFacetInterface

  functions: {
    STORAGE_GAP_1(overrides?: CallOverrides): Promise<[BigNumber]>

    STORAGE_GAP_2(overrides?: CallOverrides): Promise<[BigNumber]>

    _stakerMap(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string, boolean] & {
        index: BigNumber
        latestStakedNode: BigNumber
        amountStaked: BigNumber
        currentChallenge: string
        isStaked: boolean
      }
    >

    amountStaked(
      staker: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    arbGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<[BigNumber]>

    avmGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<[BigNumber]>

    baseStake(overrides?: CallOverrides): Promise<[BigNumber]>

    challengeExecutionBisectionDegree(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    challengeFactory(overrides?: CallOverrides): Promise<[string]>

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<[BigNumber]>

    currentChallenge(
      staker: string,
      overrides?: CallOverrides
    ): Promise<[string]>

    delayedBridge(overrides?: CallOverrides): Promise<[string]>

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<[BigNumber]>

    firstUnresolvedNode(overrides?: CallOverrides): Promise<[BigNumber]>

    forceConfirmNode(
      nodeNum: BigNumberish,
      beforeSendAcc: BytesLike,
      sendsData: BytesLike,
      sendLengths: BigNumberish[],
      afterSendCount: BigNumberish,
      afterLogAcc: BytesLike,
      afterLogCount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    forceCreateNode(
      expectedNodeHash: BytesLike,
      assertionBytes32Fields: [
        [BytesLike, BytesLike, BytesLike],
        [BytesLike, BytesLike, BytesLike]
      ],
      assertionIntFields: [
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
      ],
      sequencerBatchProof: BytesLike,
      beforeProposedBlock: BigNumberish,
      beforeInboxMaxCount: BigNumberish,
      prevNode: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    forceRefundStaker(
      staker: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    forceResolveChallenge(
      stakerA: string[],
      stakerB: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>

    getNodeHash(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>

    getStakerAddress(
      stakerNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>

    isMaster(overrides?: CallOverrides): Promise<[boolean]>

    isStaked(staker: string, overrides?: CallOverrides): Promise<[boolean]>

    isZombie(staker: string, overrides?: CallOverrides): Promise<[boolean]>

    lastStakeBlock(overrides?: CallOverrides): Promise<[BigNumber]>

    latestConfirmed(overrides?: CallOverrides): Promise<[BigNumber]>

    latestNodeCreated(overrides?: CallOverrides): Promise<[BigNumber]>

    latestStakedNode(
      staker: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<[BigNumber]>

    nodeFactory(overrides?: CallOverrides): Promise<[string]>

    outbox(overrides?: CallOverrides): Promise<[string]>

    owner(overrides?: CallOverrides): Promise<[string]>

    pause(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    paused(overrides?: CallOverrides): Promise<[boolean]>

    removeOldOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    resume(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    rollupEventBridge(overrides?: CallOverrides): Promise<[string]>

    sequencerBridge(overrides?: CallOverrides): Promise<[string]>

    setAvmGasSpeedLimitPerBlock(
      newAvmGasSpeedLimitPerBlock: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setBaseStake(
      newBaseStake: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setChallengeExecutionBisectionDegree(
      newChallengeExecutionBisectionDegree: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setConfirmPeriodBlocks(
      newConfirmPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setFacets(
      newAdminFacet: string,
      newUserFacet: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setInbox(
      _inbox: string,
      _enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setIsSequencer(
      newSequencer: string,
      isSequencer: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setMinimumAssertionPeriod(
      newPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setSequencerInboxMaxDelay(
      newSequencerInboxMaxDelayBlocks: BigNumberish,
      newSequencerInboxMaxDelaySeconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setStakeToken(
      newStakeToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setValidator(
      _validator: string[],
      _val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setWhitelistEntries(
      whitelist: string,
      user: string[],
      val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    stakeToken(overrides?: CallOverrides): Promise<[string]>

    stakerCount(overrides?: CallOverrides): Promise<[BigNumber]>

    updateWhitelistConsumers(
      whitelist: string,
      newWhitelist: string,
      targets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    upgradeBeacon(
      beacon: string,
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    withdrawableFunds(
      owner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    zombieAddress(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>

    zombieCount(overrides?: CallOverrides): Promise<[BigNumber]>

    zombieLatestStakedNode(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>
  }

  STORAGE_GAP_1(overrides?: CallOverrides): Promise<BigNumber>

  STORAGE_GAP_2(overrides?: CallOverrides): Promise<BigNumber>

  _stakerMap(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, string, boolean] & {
      index: BigNumber
      latestStakedNode: BigNumber
      amountStaked: BigNumber
      currentChallenge: string
      isStaked: boolean
    }
  >

  amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>

  arbGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

  avmGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

  baseStake(overrides?: CallOverrides): Promise<BigNumber>

  challengeExecutionBisectionDegree(
    overrides?: CallOverrides
  ): Promise<BigNumber>

  challengeFactory(overrides?: CallOverrides): Promise<string>

  confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>

  currentChallenge(staker: string, overrides?: CallOverrides): Promise<string>

  delayedBridge(overrides?: CallOverrides): Promise<string>

  extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>

  firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>

  forceConfirmNode(
    nodeNum: BigNumberish,
    beforeSendAcc: BytesLike,
    sendsData: BytesLike,
    sendLengths: BigNumberish[],
    afterSendCount: BigNumberish,
    afterLogAcc: BytesLike,
    afterLogCount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  forceCreateNode(
    expectedNodeHash: BytesLike,
    assertionBytes32Fields: [
      [BytesLike, BytesLike, BytesLike],
      [BytesLike, BytesLike, BytesLike]
    ],
    assertionIntFields: [
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
    ],
    sequencerBatchProof: BytesLike,
    beforeProposedBlock: BigNumberish,
    beforeInboxMaxCount: BigNumberish,
    prevNode: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  forceRefundStaker(
    staker: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  forceResolveChallenge(
    stakerA: string[],
    stakerB: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<string>

  getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<string>

  getStakerAddress(
    stakerNum: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>

  isMaster(overrides?: CallOverrides): Promise<boolean>

  isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>

  isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>

  lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>

  latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>

  latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>

  latestStakedNode(
    staker: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>

  nodeFactory(overrides?: CallOverrides): Promise<string>

  outbox(overrides?: CallOverrides): Promise<string>

  owner(overrides?: CallOverrides): Promise<string>

  pause(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  paused(overrides?: CallOverrides): Promise<boolean>

  removeOldOutbox(
    _outbox: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  resume(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  rollupEventBridge(overrides?: CallOverrides): Promise<string>

  sequencerBridge(overrides?: CallOverrides): Promise<string>

  setAvmGasSpeedLimitPerBlock(
    newAvmGasSpeedLimitPerBlock: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setBaseStake(
    newBaseStake: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setChallengeExecutionBisectionDegree(
    newChallengeExecutionBisectionDegree: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setConfirmPeriodBlocks(
    newConfirmPeriod: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setExtraChallengeTimeBlocks(
    newExtraTimeBlocks: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setFacets(
    newAdminFacet: string,
    newUserFacet: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setInbox(
    _inbox: string,
    _enabled: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setIsSequencer(
    newSequencer: string,
    isSequencer: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setMinimumAssertionPeriod(
    newPeriod: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setOutbox(
    _outbox: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setOwner(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setSequencerInboxMaxDelay(
    newSequencerInboxMaxDelayBlocks: BigNumberish,
    newSequencerInboxMaxDelaySeconds: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setStakeToken(
    newStakeToken: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setValidator(
    _validator: string[],
    _val: boolean[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setWhitelistEntries(
    whitelist: string,
    user: string[],
    val: boolean[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  stakeToken(overrides?: CallOverrides): Promise<string>

  stakerCount(overrides?: CallOverrides): Promise<BigNumber>

  updateWhitelistConsumers(
    whitelist: string,
    newWhitelist: string,
    targets: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  upgradeBeacon(
    beacon: string,
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  withdrawableFunds(
    owner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  zombieAddress(
    zombieNum: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>

  zombieCount(overrides?: CallOverrides): Promise<BigNumber>

  zombieLatestStakedNode(
    zombieNum: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  callStatic: {
    STORAGE_GAP_1(overrides?: CallOverrides): Promise<BigNumber>

    STORAGE_GAP_2(overrides?: CallOverrides): Promise<BigNumber>

    _stakerMap(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string, boolean] & {
        index: BigNumber
        latestStakedNode: BigNumber
        amountStaked: BigNumber
        currentChallenge: string
        isStaked: boolean
      }
    >

    amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>

    arbGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

    avmGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

    baseStake(overrides?: CallOverrides): Promise<BigNumber>

    challengeExecutionBisectionDegree(
      overrides?: CallOverrides
    ): Promise<BigNumber>

    challengeFactory(overrides?: CallOverrides): Promise<string>

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>

    currentChallenge(staker: string, overrides?: CallOverrides): Promise<string>

    delayedBridge(overrides?: CallOverrides): Promise<string>

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>

    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>

    forceConfirmNode(
      nodeNum: BigNumberish,
      beforeSendAcc: BytesLike,
      sendsData: BytesLike,
      sendLengths: BigNumberish[],
      afterSendCount: BigNumberish,
      afterLogAcc: BytesLike,
      afterLogCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    forceCreateNode(
      expectedNodeHash: BytesLike,
      assertionBytes32Fields: [
        [BytesLike, BytesLike, BytesLike],
        [BytesLike, BytesLike, BytesLike]
      ],
      assertionIntFields: [
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
      ],
      sequencerBatchProof: BytesLike,
      beforeProposedBlock: BigNumberish,
      beforeInboxMaxCount: BigNumberish,
      prevNode: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    forceRefundStaker(
      staker: string[],
      overrides?: CallOverrides
    ): Promise<void>

    forceResolveChallenge(
      stakerA: string[],
      stakerB: string[],
      overrides?: CallOverrides
    ): Promise<void>

    getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<string>

    getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<string>

    getStakerAddress(
      stakerNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>

    isMaster(overrides?: CallOverrides): Promise<boolean>

    isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>

    isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>

    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>

    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>

    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>

    latestStakedNode(
      staker: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>

    nodeFactory(overrides?: CallOverrides): Promise<string>

    outbox(overrides?: CallOverrides): Promise<string>

    owner(overrides?: CallOverrides): Promise<string>

    pause(overrides?: CallOverrides): Promise<void>

    paused(overrides?: CallOverrides): Promise<boolean>

    removeOldOutbox(_outbox: string, overrides?: CallOverrides): Promise<void>

    resume(overrides?: CallOverrides): Promise<void>

    rollupEventBridge(overrides?: CallOverrides): Promise<string>

    sequencerBridge(overrides?: CallOverrides): Promise<string>

    setAvmGasSpeedLimitPerBlock(
      newAvmGasSpeedLimitPerBlock: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setBaseStake(
      newBaseStake: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setChallengeExecutionBisectionDegree(
      newChallengeExecutionBisectionDegree: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setConfirmPeriodBlocks(
      newConfirmPeriod: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setFacets(
      newAdminFacet: string,
      newUserFacet: string,
      overrides?: CallOverrides
    ): Promise<void>

    setInbox(
      _inbox: string,
      _enabled: boolean,
      overrides?: CallOverrides
    ): Promise<void>

    setIsSequencer(
      newSequencer: string,
      isSequencer: boolean,
      overrides?: CallOverrides
    ): Promise<void>

    setMinimumAssertionPeriod(
      newPeriod: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setOutbox(_outbox: string, overrides?: CallOverrides): Promise<void>

    setOwner(newOwner: string, overrides?: CallOverrides): Promise<void>

    setSequencerInboxMaxDelay(
      newSequencerInboxMaxDelayBlocks: BigNumberish,
      newSequencerInboxMaxDelaySeconds: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setStakeToken(
      newStakeToken: string,
      overrides?: CallOverrides
    ): Promise<void>

    setValidator(
      _validator: string[],
      _val: boolean[],
      overrides?: CallOverrides
    ): Promise<void>

    setWhitelistEntries(
      whitelist: string,
      user: string[],
      val: boolean[],
      overrides?: CallOverrides
    ): Promise<void>

    stakeToken(overrides?: CallOverrides): Promise<string>

    stakerCount(overrides?: CallOverrides): Promise<BigNumber>

    updateWhitelistConsumers(
      whitelist: string,
      newWhitelist: string,
      targets: string[],
      overrides?: CallOverrides
    ): Promise<void>

    upgradeBeacon(
      beacon: string,
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>

    withdrawableFunds(
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    zombieAddress(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>

    zombieCount(overrides?: CallOverrides): Promise<BigNumber>

    zombieLatestStakedNode(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>
  }

  filters: {
    NodeConfirmed(
      nodeNum?: BigNumberish | null,
      afterSendAcc?: null,
      afterSendCount?: null,
      afterLogAcc?: null,
      afterLogCount?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string, BigNumber],
      {
        nodeNum: BigNumber
        afterSendAcc: string
        afterSendCount: BigNumber
        afterLogAcc: string
        afterLogCount: BigNumber
      }
    >

    NodeCreated(
      nodeNum?: BigNumberish | null,
      parentNodeHash?: BytesLike | null,
      nodeHash?: null,
      executionHash?: null,
      inboxMaxCount?: null,
      afterInboxBatchEndCount?: null,
      afterInboxBatchAcc?: null,
      assertionBytes32Fields?: null,
      assertionIntFields?: null
    ): TypedEventFilter<
      [
        BigNumber,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        [[string, string, string], [string, string, string]],
        [
          [BigNumber, BigNumber, BigNumber, BigNumber],
          [BigNumber, BigNumber, BigNumber, BigNumber]
        ]
      ],
      {
        nodeNum: BigNumber
        parentNodeHash: string
        nodeHash: string
        executionHash: string
        inboxMaxCount: BigNumber
        afterInboxBatchEndCount: BigNumber
        afterInboxBatchAcc: string
        assertionBytes32Fields: [
          [string, string, string],
          [string, string, string]
        ]
        assertionIntFields: [
          [BigNumber, BigNumber, BigNumber, BigNumber],
          [BigNumber, BigNumber, BigNumber, BigNumber]
        ]
      }
    >

    NodeRejected(
      nodeNum?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { nodeNum: BigNumber }>

    OwnerFunctionCalled(
      id?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { id: BigNumber }>

    Paused(account?: null): TypedEventFilter<[string], { account: string }>

    RollupChallengeStarted(
      challengeContract?: string | null,
      asserter?: null,
      challenger?: null,
      challengedNode?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        challengeContract: string
        asserter: string
        challenger: string
        challengedNode: BigNumber
      }
    >

    RollupCreated(
      machineHash?: null
    ): TypedEventFilter<[string], { machineHash: string }>

    Unpaused(account?: null): TypedEventFilter<[string], { account: string }>

    UserStakeUpdated(
      user?: string | null,
      initialBalance?: null,
      finalBalance?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; initialBalance: BigNumber; finalBalance: BigNumber }
    >

    UserWithdrawableFundsUpdated(
      user?: string | null,
      initialBalance?: null,
      finalBalance?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; initialBalance: BigNumber; finalBalance: BigNumber }
    >
  }

  estimateGas: {
    STORAGE_GAP_1(overrides?: CallOverrides): Promise<BigNumber>

    STORAGE_GAP_2(overrides?: CallOverrides): Promise<BigNumber>

    _stakerMap(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

    amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>

    arbGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

    avmGasSpeedLimitPerBlock(overrides?: CallOverrides): Promise<BigNumber>

    baseStake(overrides?: CallOverrides): Promise<BigNumber>

    challengeExecutionBisectionDegree(
      overrides?: CallOverrides
    ): Promise<BigNumber>

    challengeFactory(overrides?: CallOverrides): Promise<BigNumber>

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>

    currentChallenge(
      staker: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    delayedBridge(overrides?: CallOverrides): Promise<BigNumber>

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>

    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>

    forceConfirmNode(
      nodeNum: BigNumberish,
      beforeSendAcc: BytesLike,
      sendsData: BytesLike,
      sendLengths: BigNumberish[],
      afterSendCount: BigNumberish,
      afterLogAcc: BytesLike,
      afterLogCount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    forceCreateNode(
      expectedNodeHash: BytesLike,
      assertionBytes32Fields: [
        [BytesLike, BytesLike, BytesLike],
        [BytesLike, BytesLike, BytesLike]
      ],
      assertionIntFields: [
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
      ],
      sequencerBatchProof: BytesLike,
      beforeProposedBlock: BigNumberish,
      beforeInboxMaxCount: BigNumberish,
      prevNode: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    forceRefundStaker(
      staker: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    forceResolveChallenge(
      stakerA: string[],
      stakerB: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    getNode(
      nodeNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getNodeHash(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getStakerAddress(
      stakerNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    isMaster(overrides?: CallOverrides): Promise<BigNumber>

    isStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>

    isZombie(staker: string, overrides?: CallOverrides): Promise<BigNumber>

    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>

    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>

    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>

    latestStakedNode(
      staker: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>

    nodeFactory(overrides?: CallOverrides): Promise<BigNumber>

    outbox(overrides?: CallOverrides): Promise<BigNumber>

    owner(overrides?: CallOverrides): Promise<BigNumber>

    pause(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    paused(overrides?: CallOverrides): Promise<BigNumber>

    removeOldOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    resume(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    rollupEventBridge(overrides?: CallOverrides): Promise<BigNumber>

    sequencerBridge(overrides?: CallOverrides): Promise<BigNumber>

    setAvmGasSpeedLimitPerBlock(
      newAvmGasSpeedLimitPerBlock: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setBaseStake(
      newBaseStake: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setChallengeExecutionBisectionDegree(
      newChallengeExecutionBisectionDegree: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setConfirmPeriodBlocks(
      newConfirmPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setFacets(
      newAdminFacet: string,
      newUserFacet: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setInbox(
      _inbox: string,
      _enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setIsSequencer(
      newSequencer: string,
      isSequencer: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setMinimumAssertionPeriod(
      newPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setSequencerInboxMaxDelay(
      newSequencerInboxMaxDelayBlocks: BigNumberish,
      newSequencerInboxMaxDelaySeconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setStakeToken(
      newStakeToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setValidator(
      _validator: string[],
      _val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setWhitelistEntries(
      whitelist: string,
      user: string[],
      val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    stakeToken(overrides?: CallOverrides): Promise<BigNumber>

    stakerCount(overrides?: CallOverrides): Promise<BigNumber>

    updateWhitelistConsumers(
      whitelist: string,
      newWhitelist: string,
      targets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    upgradeBeacon(
      beacon: string,
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    withdrawableFunds(
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    zombieAddress(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    zombieCount(overrides?: CallOverrides): Promise<BigNumber>

    zombieLatestStakedNode(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>
  }

  populateTransaction: {
    STORAGE_GAP_1(overrides?: CallOverrides): Promise<PopulatedTransaction>

    STORAGE_GAP_2(overrides?: CallOverrides): Promise<PopulatedTransaction>

    _stakerMap(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    amountStaked(
      staker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    arbGasSpeedLimitPerBlock(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    avmGasSpeedLimitPerBlock(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    baseStake(overrides?: CallOverrides): Promise<PopulatedTransaction>

    challengeExecutionBisectionDegree(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    challengeFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>

    confirmPeriodBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    currentChallenge(
      staker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    delayedBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>

    extraChallengeTimeBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    firstUnresolvedNode(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    forceConfirmNode(
      nodeNum: BigNumberish,
      beforeSendAcc: BytesLike,
      sendsData: BytesLike,
      sendLengths: BigNumberish[],
      afterSendCount: BigNumberish,
      afterLogAcc: BytesLike,
      afterLogCount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    forceCreateNode(
      expectedNodeHash: BytesLike,
      assertionBytes32Fields: [
        [BytesLike, BytesLike, BytesLike],
        [BytesLike, BytesLike, BytesLike]
      ],
      assertionIntFields: [
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
        [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
      ],
      sequencerBatchProof: BytesLike,
      beforeProposedBlock: BigNumberish,
      beforeInboxMaxCount: BigNumberish,
      prevNode: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    forceRefundStaker(
      staker: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    forceResolveChallenge(
      stakerA: string[],
      stakerB: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    getNode(
      nodeNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getNodeHash(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getStakerAddress(
      stakerNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isMaster(overrides?: CallOverrides): Promise<PopulatedTransaction>

    isStaked(
      staker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isZombie(
      staker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    lastStakeBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>

    latestConfirmed(overrides?: CallOverrides): Promise<PopulatedTransaction>

    latestNodeCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>

    latestStakedNode(
      staker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    minimumAssertionPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    nodeFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>

    outbox(overrides?: CallOverrides): Promise<PopulatedTransaction>

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    pause(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>

    removeOldOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    resume(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    rollupEventBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>

    sequencerBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>

    setAvmGasSpeedLimitPerBlock(
      newAvmGasSpeedLimitPerBlock: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setBaseStake(
      newBaseStake: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setChallengeExecutionBisectionDegree(
      newChallengeExecutionBisectionDegree: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setConfirmPeriodBlocks(
      newConfirmPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setFacets(
      newAdminFacet: string,
      newUserFacet: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setInbox(
      _inbox: string,
      _enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setIsSequencer(
      newSequencer: string,
      isSequencer: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setMinimumAssertionPeriod(
      newPeriod: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setOutbox(
      _outbox: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setSequencerInboxMaxDelay(
      newSequencerInboxMaxDelayBlocks: BigNumberish,
      newSequencerInboxMaxDelaySeconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setStakeToken(
      newStakeToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setValidator(
      _validator: string[],
      _val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setWhitelistEntries(
      whitelist: string,
      user: string[],
      val: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    stakeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>

    stakerCount(overrides?: CallOverrides): Promise<PopulatedTransaction>

    updateWhitelistConsumers(
      whitelist: string,
      newWhitelist: string,
      targets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    upgradeBeacon(
      beacon: string,
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    withdrawableFunds(
      owner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    zombieAddress(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    zombieCount(overrides?: CallOverrides): Promise<PopulatedTransaction>

    zombieLatestStakedNode(
      zombieNum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>
  }
}
