/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from 'ethers'
import { BytesLike } from '@ethersproject/bytes'
import { Listener, Provider } from '@ethersproject/providers'
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi'
import { TypedEventFilter, TypedEvent, TypedListener } from './commons'

interface IBridgeInterface extends ethers.utils.Interface {
  functions: {
    'activeOutbox()': FunctionFragment
    'allowedInboxes(address)': FunctionFragment
    'allowedOutboxes(address)': FunctionFragment
    'deliverMessageToInbox(uint8,address,bytes32)': FunctionFragment
    'executeCall(address,uint256,bytes)': FunctionFragment
    'inboxAccs(uint256)': FunctionFragment
    'messageCount()': FunctionFragment
    'setInbox(address,bool)': FunctionFragment
    'setOutbox(address,bool)': FunctionFragment
  }

  encodeFunctionData(
    functionFragment: 'activeOutbox',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'allowedInboxes',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'allowedOutboxes',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'deliverMessageToInbox',
    values: [BigNumberish, string, BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'executeCall',
    values: [string, BigNumberish, BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'inboxAccs',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'messageCount',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'setInbox',
    values: [string, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'setOutbox',
    values: [string, boolean]
  ): string

  decodeFunctionResult(
    functionFragment: 'activeOutbox',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'allowedInboxes',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'allowedOutboxes',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'deliverMessageToInbox',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'executeCall', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'inboxAccs', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'messageCount',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'setInbox', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setOutbox', data: BytesLike): Result

  events: {
    'BridgeCallTriggered(address,address,uint256,bytes)': EventFragment
    'InboxToggle(address,bool)': EventFragment
    'MessageDelivered(uint256,bytes32,address,uint8,address,bytes32)': EventFragment
    'OutboxToggle(address,bool)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'BridgeCallTriggered'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'InboxToggle'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'MessageDelivered'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OutboxToggle'): EventFragment
}

export class IBridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this

  listeners(eventName?: string): Array<Listener>
  off(eventName: string, listener: Listener): this
  on(eventName: string, listener: Listener): this
  once(eventName: string, listener: Listener): this
  removeListener(eventName: string, listener: Listener): this
  removeAllListeners(eventName?: string): this

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>

  interface: IBridgeInterface

  functions: {
    activeOutbox(overrides?: CallOverrides): Promise<[string]>

    allowedInboxes(inbox: string, overrides?: CallOverrides): Promise<[boolean]>

    allowedOutboxes(
      outbox: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    deliverMessageToInbox(
      kind: BigNumberish,
      sender: string,
      messageDataHash: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    executeCall(
      destAddr: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<[string]>

    messageCount(overrides?: CallOverrides): Promise<[BigNumber]>

    setInbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setOutbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>
  }

  activeOutbox(overrides?: CallOverrides): Promise<string>

  allowedInboxes(inbox: string, overrides?: CallOverrides): Promise<boolean>

  allowedOutboxes(outbox: string, overrides?: CallOverrides): Promise<boolean>

  deliverMessageToInbox(
    kind: BigNumberish,
    sender: string,
    messageDataHash: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  executeCall(
    destAddr: string,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<string>

  messageCount(overrides?: CallOverrides): Promise<BigNumber>

  setInbox(
    inbox: string,
    enabled: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setOutbox(
    inbox: string,
    enabled: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  callStatic: {
    activeOutbox(overrides?: CallOverrides): Promise<string>

    allowedInboxes(inbox: string, overrides?: CallOverrides): Promise<boolean>

    allowedOutboxes(outbox: string, overrides?: CallOverrides): Promise<boolean>

    deliverMessageToInbox(
      kind: BigNumberish,
      sender: string,
      messageDataHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    executeCall(
      destAddr: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean, string] & { success: boolean; returnData: string }>

    inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<string>

    messageCount(overrides?: CallOverrides): Promise<BigNumber>

    setInbox(
      inbox: string,
      enabled: boolean,
      overrides?: CallOverrides
    ): Promise<void>

    setOutbox(
      inbox: string,
      enabled: boolean,
      overrides?: CallOverrides
    ): Promise<void>
  }

  filters: {
    BridgeCallTriggered(
      outbox?: string | null,
      destAddr?: string | null,
      amount?: null,
      data?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string],
      { outbox: string; destAddr: string; amount: BigNumber; data: string }
    >

    InboxToggle(
      inbox?: string | null,
      enabled?: null
    ): TypedEventFilter<[string, boolean], { inbox: string; enabled: boolean }>

    MessageDelivered(
      messageIndex?: BigNumberish | null,
      beforeInboxAcc?: BytesLike | null,
      inbox?: null,
      kind?: null,
      sender?: null,
      messageDataHash?: null
    ): TypedEventFilter<
      [BigNumber, string, string, number, string, string],
      {
        messageIndex: BigNumber
        beforeInboxAcc: string
        inbox: string
        kind: number
        sender: string
        messageDataHash: string
      }
    >

    OutboxToggle(
      outbox?: string | null,
      enabled?: null
    ): TypedEventFilter<[string, boolean], { outbox: string; enabled: boolean }>
  }

  estimateGas: {
    activeOutbox(overrides?: CallOverrides): Promise<BigNumber>

    allowedInboxes(inbox: string, overrides?: CallOverrides): Promise<BigNumber>

    allowedOutboxes(
      outbox: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    deliverMessageToInbox(
      kind: BigNumberish,
      sender: string,
      messageDataHash: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    executeCall(
      destAddr: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    inboxAccs(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    messageCount(overrides?: CallOverrides): Promise<BigNumber>

    setInbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setOutbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>
  }

  populateTransaction: {
    activeOutbox(overrides?: CallOverrides): Promise<PopulatedTransaction>

    allowedInboxes(
      inbox: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    allowedOutboxes(
      outbox: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    deliverMessageToInbox(
      kind: BigNumberish,
      sender: string,
      messageDataHash: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    executeCall(
      destAddr: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    inboxAccs(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    messageCount(overrides?: CallOverrides): Promise<PopulatedTransaction>

    setInbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setOutbox(
      inbox: string,
      enabled: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>
  }
}
